<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>fcl module &mdash; cls-python 0.1.4 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="subtypes module" href="subtypes.module.html" />
    <link rel="prev" title="enumeration module" href="enumeration.module.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> cls-python
          </a>
              <div class="version">
                0.1.4
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../readme.html">CLS-Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">Usage</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../modules.html">Module: cls-python</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../modules.html#submodules">Submodules</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="cls_json.module.html">cls_json module</a></li>
<li class="toctree-l3"><a class="reference internal" href="debug_util.module.html">debug_util module</a></li>
<li class="toctree-l3"><a class="reference internal" href="enumeration.module.html">enumeration module</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">fcl module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cls.fcl.Apply"><code class="docutils literal notranslate"><span class="pre">Apply</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#cls.fcl.Combinator"><code class="docutils literal notranslate"><span class="pre">Combinator</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#cls.fcl.Failed"><code class="docutils literal notranslate"><span class="pre">Failed</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#cls.fcl.FiniteCombinatoryLogic"><code class="docutils literal notranslate"><span class="pre">FiniteCombinatoryLogic</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#cls.fcl.InhabitationResult"><code class="docutils literal notranslate"><span class="pre">InhabitationResult</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#cls.fcl.Rule"><code class="docutils literal notranslate"><span class="pre">Rule</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#cls.fcl.Tree"><code class="docutils literal notranslate"><span class="pre">Tree</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="subtypes.module.html">subtypes module</a></li>
<li class="toctree-l3"><a class="reference internal" href="types.module.html">types module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../history.html">History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">cls-python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../modules.html">Module: cls-python</a> &raquo;</li>
      <li>fcl module</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/modules/fcl.module.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-cls.fcl">
<span id="fcl-module"></span><h1>fcl module<a class="headerlink" href="#module-cls.fcl" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="cls.fcl.Apply">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cls.fcl.</span></span><span class="sig-name descname"><span class="pre">Apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">argument_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cls/fcl.html#Apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.Apply" title="Permalink to this definition"></a></dt>
<dd><p>The <cite>Apply</cite> class represents a type inference rule that applies a function to its argument.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> (<a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><em>Type</em></a>) – The resulting type after applying the function.</p></li>
<li><p><strong>function_type</strong> (<a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><em>Type</em></a>) – The type of the function being applied.</p></li>
<li><p><strong>argument_type</strong> (<a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><em>Type</em></a>) – The type of the argument being passed to the function.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="cls.fcl.Apply._abc_impl">
<span class="sig-name descname"><span class="pre">_abc_impl</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;_abc._abc_data</span> <span class="pre">object&gt;</span></em><a class="headerlink" href="#cls.fcl.Apply._abc_impl" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cls.fcl.Apply.argument_type">
<span class="sig-name descname"><span class="pre">argument_type</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></em><a class="headerlink" href="#cls.fcl.Apply.argument_type" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cls.fcl.Apply.function_type">
<span class="sig-name descname"><span class="pre">function_type</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></em><a class="headerlink" href="#cls.fcl.Apply.function_type" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cls.fcl.Apply.is_combinator">
<span class="sig-name descname"><span class="pre">is_combinator</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#cls.fcl.Apply.is_combinator" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cls.fcl.Apply.target">
<span class="sig-name descname"><span class="pre">target</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></em><a class="headerlink" href="#cls.fcl.Apply.target" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cls.fcl.Combinator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cls.fcl.</span></span><span class="sig-name descname"><span class="pre">Combinator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">combinator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cls/fcl.html#Combinator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.Combinator" title="Permalink to this definition"></a></dt>
<dd><p>A representation of a combinator rule.</p>
<p>A <cite>Combinator</cite> has two attributes:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> (<a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><em>Type</em></a>) – The target type.</p></li>
<li><p><strong>is_combinator</strong> (<em>bool</em>) – indicates if this is a combinator.</p></li>
<li><p><strong>combinator</strong> (<em>object</em>) – The combinator.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="cls.fcl.Combinator._abc_impl">
<span class="sig-name descname"><span class="pre">_abc_impl</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;_abc._abc_data</span> <span class="pre">object&gt;</span></em><a class="headerlink" href="#cls.fcl.Combinator._abc_impl" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cls.fcl.Combinator.combinator">
<span class="sig-name descname"><span class="pre">combinator</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">object</span></em><a class="headerlink" href="#cls.fcl.Combinator.combinator" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cls.fcl.Combinator.is_combinator">
<span class="sig-name descname"><span class="pre">is_combinator</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">True</span></em><a class="headerlink" href="#cls.fcl.Combinator.is_combinator" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cls.fcl.Combinator.target">
<span class="sig-name descname"><span class="pre">target</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></em><a class="headerlink" href="#cls.fcl.Combinator.target" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cls.fcl.Failed">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cls.fcl.</span></span><span class="sig-name descname"><span class="pre">Failed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cls/fcl.html#Failed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.Failed" title="Permalink to this definition"></a></dt>
<dd><p>A representation of a failed rule.</p>
<p>A <cite>Failed</cite> rule represents a situation in which the application of the rule has failed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> (<a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><em>Type</em></a>) – The target type the rule failed to apply to.</p></li>
<li><p><strong>is_combinator</strong> (<em>bool</em>) – indicates if this is a combinator.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="cls.fcl.Failed._abc_impl">
<span class="sig-name descname"><span class="pre">_abc_impl</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;_abc._abc_data</span> <span class="pre">object&gt;</span></em><a class="headerlink" href="#cls.fcl.Failed._abc_impl" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cls.fcl.Failed.is_combinator">
<span class="sig-name descname"><span class="pre">is_combinator</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#cls.fcl.Failed.is_combinator" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cls.fcl.Failed.target">
<span class="sig-name descname"><span class="pre">target</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></em><a class="headerlink" href="#cls.fcl.Failed.target" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cls.fcl.</span></span><span class="sig-name descname"><span class="pre">FiniteCombinatoryLogic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">repository</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subtypes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="subtypes.module.html#cls.subtypes.Subtypes" title="cls.subtypes.Subtypes"><span class="pre">Subtypes</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">processes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic" title="Permalink to this definition"></a></dt>
<dd><p>A class to represent finite combinatory logic.</p>
<dl class="simple">
<dt>repository<span class="classifier">dict[object, Type]</span></dt><dd><p>The repository of objects and their respective types.</p>
</dd>
<dt>subtypes<span class="classifier">Subtypes</span></dt><dd><p>The subtypes of the objects in the repository.</p>
</dd>
<dt>processes<span class="classifier">int, optional</span></dt><dd><p>The number of processes to use when splitting the repository.
Defaults to the number of CPU cores.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._accumulate_covers">
<span class="sig-name descname"><span class="pre">_accumulate_covers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_cover</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">combinator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">combinator_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">collections.deque</span><span class="p"><span class="pre">[</span></span><span class="pre">collections.deque</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Rule" title="cls.fcl.Rule"><span class="pre">cls.fcl.Rule</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._accumulate_covers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._accumulate_covers" title="Permalink to this definition"></a></dt>
<dd><p>Computes all the covers necessary for a given combinators type, a
set of types that need to be covered and a target Type that needs to be
inhabitated and converts the covers into a segmented list of lists of
rules that the inhabitation machine can process. Note: The partial from
_inhabit_cover fixes the first two arguments. This can intuitively be
understood as us checking all combinators in the repository against the
target and using the cover machine to find out if the combinator can
allow us to cover the target.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> – The Type to compute covers for.</p></li>
<li><p><strong>to_cover</strong> – A list of types for the target to be covered. Recursively computed by organized.</p></li>
<li><p><strong>combinator</strong> – The combinator that we are preparing for the cover machine.</p></li>
<li><p><strong>combinator_type</strong> – The type of the combinator.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._check_continue_cover">
<span class="sig-name descname"><span class="pre">_check_continue_cover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">splits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_cover</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'MultiArrow'</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'MultiArrow'</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'CoverMachineInstruction'</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._check_continue_cover"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._check_continue_cover" title="Permalink to this definition"></a></dt>
<dd><p>Contains all the parts of the StepRelation where CheckContinueCover
is the current head. (p.46 f.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>splits</strong> – </p></li>
<li><p><strong>to_cover</strong> – </p></li>
<li><p><strong>current_result</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._check_cover">
<span class="sig-name descname"><span class="pre">_check_cover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">splits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_cover</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'MultiArrow'</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'MultiArrow'</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'CoverMachineInstruction'</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._check_cover"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._check_cover" title="Permalink to this definition"></a></dt>
<dd><p>Contains all the parts of the Step Relation where CheckCover is the
current head. (p.46 f.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>splits</strong> – </p></li>
<li><p><strong>to_cover</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._commit_multi_arrow">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">_commit_multi_arrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">combinator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">deque</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Rule" title="cls.fcl.Rule"><span class="pre">Rule</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._commit_multi_arrow"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._commit_multi_arrow" title="Permalink to this definition"></a></dt>
<dd><p>Converts a MultiArrow into a set of rules that the inhabitation
machine can process. This is done by expanding the MultiArrow to nested
Arrows and creating the corresponding “Apply” rules. Finally, after all
Apply rules the combinator entails have been computed, the combinator
itself is added as a rule as well.</p>
<p>Note: This ordering created here is the reason why popLeft is equivalent to dropTargets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>combinator</strong> – The combinator being evaluated.</p></li>
<li><p><strong>m</strong> – The type of the combinator being evaluated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The resulting rules for the inhabitation machine to process.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._commit_updates">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">_commit_updates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">combinator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">deque</span><span class="p"><span class="pre">[</span></span><span class="pre">deque</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Rule" title="cls.fcl.Rule"><span class="pre">Rule</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._commit_updates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._commit_updates" title="Permalink to this definition"></a></dt>
<dd><p>Takes the output produced by the cover machine and converts it into
a list of lists, with each sublist representing an ordered set of Apply
rules and a Combinator rule, which can be added to the G_targets set.
The ordering is the ordering given on the bottom of page 69.</p>
<p>The MultiArrows that get expanded to Rules are not just the contents of the cover,
but use the given target instead of their own target. (Lemma 27, p. 63)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> – The target type to create new rules for.</p></li>
<li><p><strong>combinator</strong> – The combinator object that will become a rule and is associated with the created rules.</p></li>
<li><p><strong>covers</strong> – The list of MultiArrows computed by the cover machine.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The resulting list of lists, representing the segmented rules.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._compute_fail_existing">
<span class="sig-name descname"><span class="pre">_compute_fail_existing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rules</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Rule" title="cls.fcl.Rule"><span class="pre">cls.fcl.Rule</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._compute_fail_existing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._compute_fail_existing" title="Permalink to this definition"></a></dt>
<dd><p>Computes if the target or a supertype of it have already failed/been
uninhabited [1]. Also computes if the target has already been a target
in the set of rules or has already failed [2]. A supertype being
uninhabited also proves that all of its subtypes are uninhabitable.</p>
<p>If a Failed(target) is found, that means it was failed and existing.
If a Failed(supertype of target) is found, that means it failed, but we must check for existence.
If neither was the case, we know it was not failed so far, but must still check for existence.
The last case is the remaining combination.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rules</strong> – This is the set of stable rules, referred to as G_stable in the algorithm.</p></li>
<li><p><strong>target</strong> – This is the type to compute for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Tuple of Booleans, consisting of ([1], [2]) / (failed, existing).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._continue_cover">
<span class="sig-name descname"><span class="pre">_continue_cover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">splits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_cover</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'MultiArrow'</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'MultiArrow'</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'CoverMachineInstruction'</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._continue_cover"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._continue_cover" title="Permalink to this definition"></a></dt>
<dd><p>Contains all the parts of the Step Relation where ContinueCover is
the current head. (p.46 f.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>splits</strong> – </p></li>
<li><p><strong>to_cover</strong> – </p></li>
<li><p><strong>current_result</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._cover">
<span class="sig-name descname"><span class="pre">_cover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">splits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_cover</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'MultiArrow'</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'MultiArrow'</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'CoverMachineInstruction'</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._cover"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._cover" title="Permalink to this definition"></a></dt>
<dd><p>Contains all the parts of the Step Relation where Cover is the
current head. (p.46 f.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>splits</strong> – </p></li>
<li><p><strong>to_cover</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._cover_machine">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">_cover_machine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'MultiArrow'</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">program</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">collections.abc.Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'MultiArrow'</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'MultiArrow'</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'CoverMachineInstruction'</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'MultiArrow'</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._cover_machine"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._cover_machine" title="Permalink to this definition"></a></dt>
<dd><p>Receives an initial state (cover) and a list of program
instructions. These get processed in turn, by popping the head
instruction. Each instruction itself is a callable, and the
instructions implement the step relation. This function serves as a
loop that keeps executing the instructions and manages the program
stack and output state. (p.46 f.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> – A list of MultiArrows</p></li>
<li><p><strong>program</strong> – The stack of program instructions. Every Instruction</p></li>
</ul>
</dd>
</dl>
<p>is a callable and contains the actual step relation for the cover
machine (p.46f.). The step relation is given across the functions _cover,
_continue_cover, _check_continue_cover and _check_cover.
:return: The output stack, which is a List of MultiArrows, which
represents the computed cover.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._dcap">
<span class="sig-name descname"><span class="pre">_dcap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._dcap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._dcap" title="Permalink to this definition"></a></dt>
<dd><p>Given two types, checks if one is a subtype of the other. If yes,
returns the more specific type, e.g. the subtype. If no, returns the
intersection of the two.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sigma</strong> – The first type to check.</p></li>
<li><p><strong>tau</strong> – The second type to check.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The resulting type (for merging that part of the MultiArrow).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._ground_types_of">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">_ground_types_of</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rules</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Rule" title="cls.fcl.Rule"><span class="pre">cls.fcl.Rule</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._ground_types_of"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._ground_types_of" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._inhabit_cover">
<span class="sig-name descname"><span class="pre">_inhabit_cover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">todo_rules</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">deque</span><span class="p"><span class="pre">[</span></span><span class="pre">deque</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Rule" title="cls.fcl.Rule"><span class="pre">Rule</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._inhabit_cover"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._inhabit_cover" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._inhabitation_machine">
<span class="sig-name descname"><span class="pre">_inhabitation_machine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stable</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Rule" title="cls.fcl.Rule"><span class="pre">cls.fcl.Rule</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">deque</span><span class="p"><span class="pre">[</span></span><span class="pre">deque</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Rule" title="cls.fcl.Rule"><span class="pre">Rule</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._inhabitation_machine"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._inhabitation_machine" title="Permalink to this definition"></a></dt>
<dd><p>Implements the actual inhabitation machine. This calls
_inhabitation_step until the list of candidate rules to include in the
tree grammar is empty (targets). Variable stable contains the rules
that are part of the final computed tree grammar. The contents of
stable are, in fact, stable, as in the list is only appended too, and
previously committed members of the list do not get modified or
removed. (p.69 f.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stable</strong> – </p></li>
<li><p><strong>targets</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._inhabitation_step">
<span class="sig-name descname"><span class="pre">_inhabitation_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stable</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Rule" title="cls.fcl.Rule"><span class="pre">cls.fcl.Rule</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">deque</span><span class="p"><span class="pre">[</span></span><span class="pre">deque</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Rule" title="cls.fcl.Rule"><span class="pre">Rule</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._inhabitation_step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._inhabitation_step" title="Permalink to this definition"></a></dt>
<dd><p>Implements the inhabitation machine’s state transition function
(p.68).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stable</strong> – </p></li>
<li><p><strong>targets</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._merge_multi_arrow">
<span class="sig-name descname"><span class="pre">_merge_multi_arrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arrow1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arrow2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._merge_multi_arrow"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._merge_multi_arrow" title="Permalink to this definition"></a></dt>
<dd><p>Merges two MultiArrows into a single MultiArrow with correct types.
The MultiArrows have the same length. Each pair of types at the same
spot is merged by _dcap, which selects the most specific type possible
at that position (the subtype, or their intersection if there is no
inheritance). (p.46)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arrow1</strong> – The first MultiArrow.</p></li>
<li><p><strong>arrow2</strong> – The second MultiArrow.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The resulting MultiArrow from merging arrow1 and arrow2.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._omega_rules">
<span class="sig-name descname"><span class="pre">_omega_rules</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Rule" title="cls.fcl.Rule"><span class="pre">cls.fcl.Rule</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._omega_rules"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._omega_rules" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._partition_cover">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">_partition_cover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">covered</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_cover</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._partition_cover"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._partition_cover" title="Permalink to this definition"></a></dt>
<dd><p>This helper function partitions the elements of to_cover into two
lists: If they are in covered, they get added to in_covered, if they
aren’t, they get added to not_in_covered. The idea is that elements
that have already been covered are handled different then those that
still need to be covered. This function computes exactly those sets.
(p.45)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>covered</strong> – The set of types that are currently already</p>
</dd>
</dl>
<p>covered. :param to_cover: The set of types that still needs to
be covered. :return: The partitioned sets based on the
membership in covered.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._prune">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">_prune</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rules</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Rule" title="cls.fcl.Rule"><span class="pre">cls.fcl.Rule</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Rule" title="cls.fcl.Rule"><span class="pre">cls.fcl.Rule</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._prune"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._prune" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._reduce_multi_arrows">
<span class="sig-name descname"><span class="pre">_reduce_multi_arrows</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ms</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._reduce_multi_arrows"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._reduce_multi_arrows" title="Permalink to this definition"></a></dt>
<dd><p>This function eliminates all MultiArrows from the given set (cover)
that are redundant when considering subtyping.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ms</strong> – The List of MultiArrows that we want to reduce to a minimal necessary size.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The reduced List.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._split_repo">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">_split_repo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ty</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._split_repo"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._split_repo" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic._still_possible">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">_still_possible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">splits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_cover</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic._still_possible"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic._still_possible" title="Permalink to this definition"></a></dt>
<dd><p>This helper function checks each element of to_cover with regard to
if it still could be covered by the content of splits. This is very
intuitive, we check for the existence of a MultiArrow whose target is
the type to be covered, with the left part not mattering. (p.46)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>splits</strong> – The list of MultiArrows (rules if you will) that</p>
</dd>
</dl>
<p>can be used to cover the types in to_cover.
:param to_cover: The list of Types to check coverability.
:return: False, if there is any type in to_cover that can not be
produced by any MultiArrow in splits at all. Else, True. (All types
could at this step still be covered)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic.inhabit">
<span class="sig-name descname"><span class="pre">inhabit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">targets</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#cls.fcl.InhabitationResult" title="cls.fcl.InhabitationResult"><span class="pre">InhabitationResult</span></a></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic.inhabit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic.inhabit" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.FiniteCombinatoryLogic.split_ty">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">split_ty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ty</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#FiniteCombinatoryLogic.split_ty"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.FiniteCombinatoryLogic.split_ty" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cls.fcl.InhabitationResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cls.fcl.</span></span><span class="sig-name descname"><span class="pre">InhabitationResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rules</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Rule" title="cls.fcl.Rule"><span class="pre">cls.fcl.Rule</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cls/fcl.html#InhabitationResult"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.InhabitationResult" title="Permalink to this definition"></a></dt>
<dd><p>The <cite>InhabitationResult</cite> class is used to represent the inhabitation result, which is a process of finding terms that have a specific type. It stores a list of <cite>Type</cite> objects (<cite>targets</cite>) and a set of <cite>Rule</cite> objects (<cite>rules</cite>) that define the types and the terms.</p>
<p>The class provides several properties and methods to work with the result.</p>
<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.InhabitationResult.apply_result">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">apply_result</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="enumeration.module.html#cls.enumeration.Enumeration" title="cls.enumeration.Enumeration"><span class="pre">cls.enumeration.Enumeration</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Tree" title="cls.fcl.Tree"><span class="pre">cls.fcl.Tree</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#cls.fcl.Apply" title="cls.fcl.Apply"><span class="pre">Apply</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="enumeration.module.html#cls.enumeration.Enumeration" title="cls.enumeration.Enumeration"><span class="pre">Enumeration</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Tree" title="cls.fcl.Tree"><span class="pre">Tree</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#InhabitationResult.apply_result"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.InhabitationResult.apply_result" title="Permalink to this definition"></a></dt>
<dd><p>The <cite>apply_result</cite> method is a static methods that is used to create <cite>Enumeration</cite> objects for <cite>Apply</cite> rules.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.InhabitationResult.check_empty">
<span class="sig-name descname"><span class="pre">check_empty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#InhabitationResult.check_empty"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.InhabitationResult.check_empty" title="Permalink to this definition"></a></dt>
<dd><p>The <cite>check_empty</cite> method checks if a target type is in the inhabitation result.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>target</strong> (<a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><em>Type</em></a>) – is the target to check.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>True</cite> if there are no terms with the type, and <cite>False</cite> otherwise.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.InhabitationResult.combinator_result">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">combinator_result</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#cls.fcl.Combinator" title="cls.fcl.Combinator"><span class="pre">Combinator</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="enumeration.module.html#cls.enumeration.Enumeration" title="cls.enumeration.Enumeration"><span class="pre">Enumeration</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Tree" title="cls.fcl.Tree"><span class="pre">Tree</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#InhabitationResult.combinator_result"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.InhabitationResult.combinator_result" title="Permalink to this definition"></a></dt>
<dd><p>The <cite>combinator_result</cite> method is a static methods that is used to create <cite>Enumeration</cite> objects for <cite>Combinator</cite> rules.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cls.fcl.InhabitationResult.enumeration_map">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">enumeration_map</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="enumeration.module.html#cls.enumeration.Enumeration" title="cls.enumeration.Enumeration"><span class="pre">cls.enumeration.Enumeration</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Tree" title="cls.fcl.Tree"><span class="pre">cls.fcl.Tree</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#cls.fcl.InhabitationResult.enumeration_map" title="Permalink to this definition"></a></dt>
<dd><p>The <cite>enumeration_map</cite> property is a cached property that returns a dictionary where the keys are the target types,
and the values are the <cite>Enumeration</cite> objects that contain the terms of the specific types.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a dictionary.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict[<a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type">Type</a>, <a class="reference internal" href="enumeration.module.html#cls.enumeration.Enumeration" title="cls.enumeration.Enumeration">Enumeration</a>[<a class="reference internal" href="#cls.fcl.Tree" title="cls.fcl.Tree">Tree</a>]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cls.fcl.InhabitationResult.evaluated">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">evaluated</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="enumeration.module.html#cls.enumeration.Enumeration" title="cls.enumeration.Enumeration"><span class="pre">Enumeration</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#cls.fcl.InhabitationResult.evaluated" title="Permalink to this definition"></a></dt>
<dd><p>The <a href="#id1"><span class="problematic" id="id2">`</span></a>evaluated`property is a cached property that returns the evaluated result of the raw targets.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>If the number of targets is 1, the raw target is evaluated and returned as a single value.</p>
</dd>
</dl>
<p>Otherwise, the raw targets are evaluated and returned as a list of values.
:rtype: Enumeration[Any | list[Any]]</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cls.fcl.InhabitationResult.grouped_rules">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">grouped_rules</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Rule" title="cls.fcl.Rule"><span class="pre">cls.fcl.Rule</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#cls.fcl.InhabitationResult.grouped_rules" title="Permalink to this definition"></a></dt>
<dd><p>The <cite>grouped_rules</cite> property is a cached property that groups the rules based on their target type.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>It returns a dictionary where the keys are the target types, and the values are the sets of rules</p>
</dd>
</dl>
<p>that have the same target type.
:rtype: dict[Type, set[Rule]]</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cls.fcl.InhabitationResult.infinite">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">infinite</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#cls.fcl.InhabitationResult.infinite" title="Permalink to this definition"></a></dt>
<dd><p>This property signals whether the result is infinite.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><cite>True</cite> if the result is infinite, meaning that the terms with the target types can generate more terms of the same type, and <cite>False</cite> otherwise.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cls.fcl.InhabitationResult.non_empty">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">non_empty</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#cls.fcl.InhabitationResult.non_empty" title="Permalink to this definition"></a></dt>
<dd><p>This property shows if the inhabitation result has solutions for the targets.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><cite>True</cite> if there are any terms for the targets types, and <cite>False</cite> otherwise.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cls.fcl.InhabitationResult.raw">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">raw</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="enumeration.module.html#cls.enumeration.Enumeration" title="cls.enumeration.Enumeration"><span class="pre">Enumeration</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Tree" title="cls.fcl.Tree"><span class="pre">cls.fcl.Tree</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Tree" title="cls.fcl.Tree"><span class="pre">cls.fcl.Tree</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#cls.fcl.InhabitationResult.raw" title="Permalink to this definition"></a></dt>
<dd><p>The <cite>raw</cite> property is a cached property that returns an <cite>Enumeration</cite> object
that contains either a <cite>Tree</cite> or a list of <cite>Tree</cite> objects. The terms are either single terms or lists of terms.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Enumeration of resulting terms.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="enumeration.module.html#cls.enumeration.Enumeration" title="cls.enumeration.Enumeration">Enumeration</a>[<a class="reference internal" href="#cls.fcl.Tree" title="cls.fcl.Tree">Tree</a> | list[<a class="reference internal" href="#cls.fcl.Tree" title="cls.fcl.Tree">Tree</a>]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cls.fcl.InhabitationResult.rules">
<span class="sig-name descname"><span class="pre">rules</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cls.fcl.Rule" title="cls.fcl.Rule"><span class="pre">cls.fcl.Rule</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#cls.fcl.InhabitationResult.rules" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.InhabitationResult.size">
<span class="sig-name descname"><span class="pre">size</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#InhabitationResult.size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.InhabitationResult.size" title="Permalink to this definition"></a></dt>
<dd><p>The <cite>size</cite> method returns the size of the result.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>If the result is infinite, it returns -1. Otherwise, it returns the number of terms that have the target types.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cls.fcl.InhabitationResult.targets">
<span class="sig-name descname"><span class="pre">targets</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">cls.types.Type</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#cls.fcl.InhabitationResult.targets" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cls.fcl.Rule">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cls.fcl.</span></span><span class="sig-name descname"><span class="pre">Rule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_combinator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cls/fcl.html#Rule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.Rule" title="Permalink to this definition"></a></dt>
<dd><p>Abstract base class for rules.</p>
<p>A <cite>Rule</cite> is an abstract representation of a specific aspect of a type in a type system. It has two attributes:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> (<a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><em>Type</em></a>) – The target type the rule applies to.</p></li>
<li><p><strong>is_combinator</strong> (<em>bool</em>) – Whether the rule is a combinator.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="cls.fcl.Rule._abc_impl">
<span class="sig-name descname"><span class="pre">_abc_impl</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;_abc._abc_data</span> <span class="pre">object&gt;</span></em><a class="headerlink" href="#cls.fcl.Rule._abc_impl" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cls.fcl.Rule.is_combinator">
<span class="sig-name descname"><span class="pre">is_combinator</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#cls.fcl.Rule.is_combinator" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cls.fcl.Rule.target">
<span class="sig-name descname"><span class="pre">target</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="types.module.html#cls.types.Type" title="cls.types.Type"><span class="pre">Type</span></a></em><a class="headerlink" href="#cls.fcl.Rule.target" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cls.fcl.Tree">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cls.fcl.</span></span><span class="sig-name descname"><span class="pre">Tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rule:</span> <span class="pre">~cls.fcl.Rule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">children:</span> <span class="pre">tuple['Tree'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">...]</span> <span class="pre">=</span> <span class="pre">&lt;factory&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cls/fcl.html#Tree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.Tree" title="Permalink to this definition"></a></dt>
<dd><p>A class representing a tree of type rules.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rule</strong> (<a class="reference internal" href="#cls.fcl.Rule" title="cls.fcl.Rule"><em>Rule</em></a>) – The root rule of the tree.</p></li>
<li><p><strong>children</strong> (<em>tuple</em>) – The children of the tree, represented as a tuple of Tree objects. Default value is an empty tuple.</p></li>
</ul>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="cls.fcl.Tree.Evaluator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Evaluator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outer</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#cls.fcl.Tree" title="cls.fcl.Tree"><span class="pre">Tree</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cls/fcl.html#Tree.Evaluator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.Tree.Evaluator" title="Permalink to this definition"></a></dt>
<dd><p>The <cite>Evaluator</cite> class implements a computation step that evaluates a <cite>Tree</cite> instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>outer</strong> (<a class="reference internal" href="#cls.fcl.Tree" title="cls.fcl.Tree"><em>Tree</em></a>) – The <cite>Tree</cite> instance being evaluated.</p></li>
<li><p><strong>results</strong> (<em>list</em>) – A list to store the result of the evaluation.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="cls.fcl.Tree.Evaluator._abc_impl">
<span class="sig-name descname"><span class="pre">_abc_impl</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;_abc._abc_data</span> <span class="pre">object&gt;</span></em><a class="headerlink" href="#cls.fcl.Tree.Evaluator._abc_impl" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cls.fcl.Tree.children">
<span class="sig-name descname"><span class="pre">children</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'Tree'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#cls.fcl.Tree.children" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cls.fcl.Tree.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Any</span></span></span><a class="reference internal" href="../_modules/cls/fcl.html#Tree.evaluate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cls.fcl.Tree.evaluate" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the <cite>Tree</cite> instance and returns the result.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cls.fcl.Tree.rule">
<span class="sig-name descname"><span class="pre">rule</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="#cls.fcl.Rule" title="cls.fcl.Rule"><span class="pre">Rule</span></a></em><a class="headerlink" href="#cls.fcl.Tree.rule" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="enumeration.module.html" class="btn btn-neutral float-left" title="enumeration module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="subtypes.module.html" class="btn btn-neutral float-right" title="subtypes module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Jan Bessai.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>