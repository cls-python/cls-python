<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>cls.fcl &mdash; cls-python 0.1.2 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> cls-python
          </a>
              <div class="version">
                0.1.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">CLS-Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">Module: cls-python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">cls-python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>cls.fcl</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for cls.fcl</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterator</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cached_property</span><span class="p">,</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">TypeAlias</span>

<span class="kn">from</span> <span class="nn">.enumeration</span> <span class="kn">import</span> <span class="n">ComputationStep</span><span class="p">,</span> <span class="n">EmptyStep</span><span class="p">,</span> <span class="n">Enumeration</span>
<span class="kn">from</span> <span class="nn">.subtypes</span> <span class="kn">import</span> <span class="n">Subtypes</span>
<span class="kn">from</span> <span class="nn">.types</span> <span class="kn">import</span> <span class="n">Arrow</span><span class="p">,</span> <span class="n">Intersection</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>

<span class="n">MultiArrow</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Type</span><span class="p">],</span> <span class="n">Type</span><span class="p">]</span>
<span class="n">State</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;MultiArrow&quot;</span><span class="p">]</span>
<span class="n">CoverMachineInstruction</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[</span>
    <span class="p">[</span><span class="n">State</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">State</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;CoverMachineInstruction&quot;</span><span class="p">]]</span>
<span class="p">]</span>


<div class="viewcode-block" id="Rule"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.Rule">[docs]</a><span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Rule</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract base class for rules.</span>

<span class="sd">    A `Rule` is an abstract representation of a specific aspect of a type in a type system. It has two attributes:</span>

<span class="sd">    :param Type target: The target type the rule applies to.</span>
<span class="sd">    :param bool is_combinator: Whether the rule is a combinator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">target</span><span class="p">:</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kw_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">is_combinator</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kw_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="Failed"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.Failed">[docs]</a><span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Failed</span><span class="p">(</span><span class="n">Rule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A representation of a failed rule.</span>

<span class="sd">    A `Failed` rule represents a situation in which the application of the rule has failed.</span>

<span class="sd">    :param Type target: The target type the rule failed to apply to.</span>
<span class="sd">    :param bool is_combinator: indicates if this is a combinator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">target</span><span class="p">:</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">field</span><span class="p">()</span>
    <span class="n">is_combinator</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Failed(</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span></div>


<div class="viewcode-block" id="Combinator"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.Combinator">[docs]</a><span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Combinator</span><span class="p">(</span><span class="n">Rule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A representation of a combinator rule.</span>

<span class="sd">    A `Combinator` has two attributes:</span>

<span class="sd">    :param Type target: The target type.</span>
<span class="sd">    :param bool is_combinator: indicates if this is a combinator.</span>
<span class="sd">    :param object combinator: The combinator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">target</span><span class="p">:</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">field</span><span class="p">()</span>
    <span class="n">is_combinator</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">combinator</span><span class="p">:</span> <span class="nb">object</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Combinator(</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combinator</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span></div>


<div class="viewcode-block" id="Apply"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.Apply">[docs]</a><span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Apply</span><span class="p">(</span><span class="n">Rule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The `Apply` class represents a type inference rule that applies a function to its argument.</span>

<span class="sd">    :param Type target: The resulting type after applying the function.</span>
<span class="sd">    :param Type function_type: The type of the function being applied.</span>
<span class="sd">    :param Type argument_type: The type of the argument being passed to the function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">target</span><span class="p">:</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">field</span><span class="p">()</span>
    <span class="n">is_combinator</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">function_type</span><span class="p">:</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">argument_type</span><span class="p">:</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;@(</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_type</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">argument_type</span><span class="p">)</span><span class="si">}</span><span class="s2">) : </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Tree"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.Tree">[docs]</a><span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Tree</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class representing a tree of type rules.</span>

<span class="sd">    :param Rule rule: The root rule of the tree.</span>
<span class="sd">    :param tuple children: The children of the tree, represented as a tuple of Tree objects. Default value is an empty tuple.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">rule</span><span class="p">:</span> <span class="n">Rule</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">children</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="s2">&quot;Tree&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="p">())</span>

<div class="viewcode-block" id="Tree.Evaluator"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.Tree.Evaluator">[docs]</a>    <span class="k">class</span> <span class="nc">Evaluator</span><span class="p">(</span><span class="n">ComputationStep</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The `Evaluator` class implements a computation step that evaluates a `Tree` instance.</span>

<span class="sd">        :param Tree outer: The `Tree` instance being evaluated.</span>
<span class="sd">        :param list results: A list to store the result of the evaluation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outer</span><span class="p">:</span> <span class="s2">&quot;Tree&quot;</span><span class="p">,</span> <span class="n">results</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outer</span><span class="p">:</span> <span class="s2">&quot;Tree&quot;</span> <span class="o">=</span> <span class="n">outer</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="n">results</span>

        <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">ComputationStep</span><span class="p">]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Yields the next computation step to be performed.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">match</span> <span class="bp">self</span><span class="o">.</span><span class="n">outer</span><span class="o">.</span><span class="n">rule</span><span class="p">:</span>
                <span class="k">case</span><span class="w"> </span><span class="n">Combinator</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">case</span><span class="w"> </span><span class="n">Apply</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
                    <span class="n">f_arg</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                    <span class="k">yield</span> <span class="n">Tree</span><span class="o">.</span><span class="n">Evaluator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outer</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f_arg</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">Tree</span><span class="o">.</span><span class="n">Evaluator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outer</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">f_arg</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">f_arg</span><span class="p">[</span><span class="mi">0</span><span class="p">])(</span><span class="n">f_arg</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot apply rule: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">outer</span><span class="o">.</span><span class="n">rule</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">EmptyStep</span><span class="p">()</span></div>

<div class="viewcode-block" id="Tree.evaluate"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.Tree.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates the `Tree` instance and returns the result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Evaluator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a string representation of the `Tree` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">match</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="p">:</span>
            <span class="k">case</span><span class="w"> </span><span class="n">Combinator</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="p">)</span>
            <span class="k">case</span><span class="w"> </span><span class="n">Apply</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="p">)</span><span class="si">}</span><span class="s2"> @ (</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">))</span><span class="si">}</span><span class="s2">)&quot;</span></div>


<div class="viewcode-block" id="InhabitationResult"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.InhabitationResult">[docs]</a><span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">InhabitationResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The `InhabitationResult` class is used to represent the inhabitation result, which is a process of finding terms that have a specific type. It stores a list of `Type` objects (`targets`) and a set of `Rule` objects (`rules`) that define the types and the terms.</span>

<span class="sd">    The class provides several properties and methods to work with the result.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">targets</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Type</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">rules</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Rule</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">grouped_rules</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="n">Rule</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The `grouped_rules` property is a cached property that groups the rules based on their target type.</span>

<span class="sd">        :return: It returns a dictionary where the keys are the target types, and the values are the sets of rules</span>
<span class="sd">        that have the same target type.</span>
<span class="sd">        :rtype: dict[Type, set[Rule]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="n">Rule</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rules</span><span class="p">:</span>
            <span class="n">group</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Rule</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">group</span><span class="p">:</span>
                <span class="n">group</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">rule</span><span class="o">.</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">rule</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="InhabitationResult.check_empty"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.InhabitationResult.check_empty">[docs]</a>    <span class="k">def</span> <span class="nf">check_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The `check_empty` method checks if a target type is in the inhabitation result.</span>

<span class="sd">        :param target: is the target to check.</span>
<span class="sd">        :type target: Type</span>
<span class="sd">        :return: `True` if there are no terms with the type, and `False` otherwise.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouped_rules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="p">{</span><span class="n">Failed</span><span class="p">(</span><span class="n">target</span><span class="p">)}):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">Failed</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">non_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This property shows if the inhabitation result has solutions for the targets.</span>

<span class="sd">        :return: `True` if there are any terms for the targets types, and `False` otherwise.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_empty</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_empty</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">infinite</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This property signals whether the result is infinite.</span>

<span class="sd">        :return: `True` if the result is infinite, meaning that the terms with the target types can generate more terms of the same type, and `False` otherwise.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">reachable</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">rules</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouped_rules</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">entry</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">:</span>
                <span class="k">match</span> <span class="n">rule</span><span class="p">:</span>
                    <span class="k">case</span> <span class="n">Apply</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
                        <span class="n">next_reached</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">}</span>
                        <span class="n">entry</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">next_reached</span><span class="p">)</span>
                    <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                        <span class="k">pass</span>
            <span class="n">reachable</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span>

        <span class="n">changed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">to_check</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">changed</span><span class="p">:</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">next_to_check</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">to_check</span><span class="p">:</span>
                <span class="n">can_reach</span> <span class="o">=</span> <span class="n">reachable</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">can_reach</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="n">newly_reached</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                    <span class="o">*</span><span class="p">(</span><span class="n">reachable</span><span class="p">[</span><span class="n">reached</span><span class="p">]</span> <span class="k">for</span> <span class="n">reached</span> <span class="ow">in</span> <span class="n">can_reach</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">new_target</span> <span class="ow">in</span> <span class="n">newly_reached</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">new_target</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">True</span>
                    <span class="k">elif</span> <span class="n">new_target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">to_check</span><span class="p">:</span>
                        <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">next_to_check</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_target</span><span class="p">)</span>
                        <span class="n">can_reach</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_target</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">new_target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">can_reach</span><span class="p">:</span>
                        <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">can_reach</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_target</span><span class="p">)</span>
            <span class="n">to_check</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">next_to_check</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="InhabitationResult.size"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.InhabitationResult.size">[docs]</a>    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The `size` method returns the size of the result.</span>

<span class="sd">        :return: If the result is infinite, it returns -1. Otherwise, it returns the number of terms that have the target types.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">infinite</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">maximum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">unsafe_max_size</span><span class="p">()</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">all_values</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">maximum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">trees</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="n">size</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">size</span></div>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Enumeration</span><span class="p">[</span><span class="n">Tree</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The `__getitem__` method is used to access the trees of type rules for a specific target type.</span>
<span class="sd">        It takes a `Type` object as an argument and returns an `Enumeration` object that contains trees of type rules.</span>


<span class="sd">        :param target: the target you want to access terms in the result.</span>
<span class="sd">        :type target: Type</span>
<span class="sd">        :return: a enumeration of type rule trees.</span>
<span class="sd">        :rtype: Enumeration[Tree]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">enumeration_map</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">enumeration_map</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Enumeration</span><span class="o">.</span><span class="n">empty</span><span class="p">()</span>

<div class="viewcode-block" id="InhabitationResult.combinator_result"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.InhabitationResult.combinator_result">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">combinator_result</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="n">Combinator</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Enumeration</span><span class="p">[</span><span class="n">Tree</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The `combinator_result` method is a static methods that is used to create `Enumeration` objects for `Combinator` rules.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Enumeration</span><span class="o">.</span><span class="n">singleton</span><span class="p">(</span><span class="n">Tree</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">()))</span></div>

<div class="viewcode-block" id="InhabitationResult.apply_result"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.InhabitationResult.apply_result">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">apply_result</span><span class="p">(</span>
        <span class="n">result</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="n">Enumeration</span><span class="p">[</span><span class="n">Tree</span><span class="p">]],</span> <span class="n">r</span><span class="p">:</span> <span class="n">Apply</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Enumeration</span><span class="p">[</span><span class="n">Tree</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The `apply_result` method is a static methods that is used to create `Enumeration` objects for `Apply` rules.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">mkapp</span><span class="p">(</span><span class="n">left_and_right</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Tree</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">left_and_right</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">left_and_right</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">def</span> <span class="nf">apf</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">function_type</span><span class="p">]</span> <span class="o">*</span> <span class="n">result</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">argument_type</span><span class="p">])</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mkapp</span><span class="p">)</span><span class="o">.</span><span class="n">pay</span><span class="p">()</span>

        <span class="n">applied</span> <span class="o">=</span> <span class="n">Enumeration</span><span class="o">.</span><span class="n">lazy</span><span class="p">(</span><span class="n">apf</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">applied</span></div>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">enumeration_map</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="n">Enumeration</span><span class="p">[</span><span class="n">Tree</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The `enumeration_map` property is a cached property that returns a dictionary where the keys are the target types,</span>
<span class="sd">        and the values are the `Enumeration` objects that contain the terms of the specific types.</span>

<span class="sd">        :return: a dictionary.</span>
<span class="sd">        :rtype: dict[Type, Enumeration[Tree]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="n">Enumeration</span><span class="p">[</span><span class="n">Tree</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">rules</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouped_rules</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">_enum</span><span class="p">:</span> <span class="n">Enumeration</span><span class="p">[</span><span class="n">Tree</span><span class="p">]</span> <span class="o">=</span> <span class="n">Enumeration</span><span class="o">.</span><span class="n">empty</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">:</span>
                <span class="k">match</span> <span class="n">rule</span><span class="p">:</span>
                    <span class="k">case</span><span class="w"> </span><span class="n">Combinator</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">as</span> <span class="n">r</span><span class="p">:</span>
                        <span class="n">_enum</span> <span class="o">=</span> <span class="n">_enum</span> <span class="o">+</span> <span class="n">InhabitationResult</span><span class="o">.</span><span class="n">combinator_result</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                    <span class="k">case</span><span class="w"> </span><span class="n">Apply</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">as</span> <span class="n">r</span><span class="p">:</span>
                        <span class="n">_enum</span> <span class="o">=</span> <span class="n">_enum</span> <span class="o">+</span> <span class="n">InhabitationResult</span><span class="o">.</span><span class="n">apply_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                    <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                        <span class="k">pass</span>
            <span class="n">result</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="n">_enum</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">raw</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Enumeration</span><span class="p">[</span><span class="n">Tree</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">Tree</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The `raw` property is a cached property that returns an `Enumeration` object</span>
<span class="sd">        that contains either a `Tree` or a list of `Tree` objects. The terms are either single terms or lists of terms.</span>

<span class="sd">        :return: Enumeration of resulting terms.</span>
<span class="sd">        :rtype: Enumeration[Tree | list[Tree]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Enumeration</span><span class="o">.</span><span class="n">empty</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">enumeration_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="p">:</span> <span class="n">Enumeration</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Tree</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Enumeration</span><span class="o">.</span><span class="n">singleton</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">enumeration_map</span><span class="p">[</span><span class="n">target</span><span class="p">])</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">evaluated</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Enumeration</span><span class="p">[</span><span class="n">Any</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The `evaluated`property is a cached property that returns the evaluated result of the raw targets.</span>

<span class="sd">        :return: If the number of targets is 1, the raw target is evaluated and returned as a single value.</span>
<span class="sd">        Otherwise, the raw targets are evaluated and returned as a list of values.</span>
<span class="sd">        :rtype: Enumeration[Any | list[Any]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">evaluate</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(),</span> <span class="n">l</span><span class="p">)))</span></div>


<div class="viewcode-block" id="FiniteCombinatoryLogic"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic">[docs]</a><span class="k">class</span> <span class="nc">FiniteCombinatoryLogic</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class to represent finite combinatory logic.</span>

<span class="sd">    repository : dict[object, Type]</span>
<span class="sd">        The repository of objects and their respective types.</span>

<span class="sd">    subtypes : Subtypes</span>
<span class="sd">        The subtypes of the objects in the repository.</span>

<span class="sd">    processes : int, optional</span>
<span class="sd">        The number of processes to use when splitting the repository.</span>
<span class="sd">        Defaults to the number of CPU cores.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">repository</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">object</span><span class="p">,</span> <span class="n">Type</span><span class="p">],</span>
        <span class="n">subtypes</span><span class="p">:</span> <span class="n">Subtypes</span><span class="p">,</span>
        <span class="n">processes</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">(),</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processes</span> <span class="o">=</span> <span class="n">processes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">repository</span> <span class="o">=</span> <span class="n">repository</span>
        <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">splitted_repository</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">object</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">]]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span>
                    <span class="n">FiniteCombinatoryLogic</span><span class="o">.</span><span class="n">_split_repo</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">repository</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span>
                    <span class="n">chunksize</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">repository</span><span class="p">)</span> <span class="o">//</span> <span class="n">processes</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subtypes</span> <span class="o">=</span> <span class="n">subtypes</span>

<div class="viewcode-block" id="FiniteCombinatoryLogic._split_repo"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._split_repo">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_split_repo</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">ty</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">object</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">]]]:</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">FiniteCombinatoryLogic</span><span class="o">.</span><span class="n">split_ty</span><span class="p">(</span><span class="n">ty</span><span class="p">)</span></div>

<div class="viewcode-block" id="FiniteCombinatoryLogic.split_ty"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic.split_ty">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">split_ty</span><span class="p">(</span><span class="n">ty</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">]]:</span>
        <span class="k">def</span> <span class="nf">safe_split</span><span class="p">(</span>
            <span class="n">xss</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">]],</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">]]]:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">xss</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">xss</span> <span class="k">else</span> <span class="p">[]),</span> <span class="n">xss</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">def</span> <span class="nf">split_rec</span><span class="p">(</span>
            <span class="n">to_split</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">srcs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Type</span><span class="p">],</span> <span class="n">delta</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">]]</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">]]:</span>
            <span class="k">match</span> <span class="n">to_split</span><span class="p">:</span>
                <span class="k">case</span> <span class="n">Arrow</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">tgt</span><span class="p">):</span>
                    <span class="n">xs</span><span class="p">,</span> <span class="n">xss</span> <span class="o">=</span> <span class="n">safe_split</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
                    <span class="n">next_srcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">src</span><span class="p">,</span> <span class="o">*</span><span class="n">srcs</span><span class="p">]</span>
                    <span class="k">return</span> <span class="p">[[(</span><span class="n">next_srcs</span><span class="p">,</span> <span class="n">tgt</span><span class="p">),</span> <span class="o">*</span><span class="n">xs</span><span class="p">],</span> <span class="o">*</span><span class="n">split_rec</span><span class="p">(</span><span class="n">tgt</span><span class="p">,</span> <span class="n">next_srcs</span><span class="p">,</span> <span class="n">xss</span><span class="p">)]</span>
                <span class="k">case</span> <span class="n">Intersection</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span> <span class="k">if</span> <span class="n">sigma</span><span class="o">.</span><span class="n">is_omega</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">split_rec</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">srcs</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
                <span class="k">case</span> <span class="n">Intersection</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span> <span class="k">if</span> <span class="n">tau</span><span class="o">.</span><span class="n">is_omega</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">split_rec</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">srcs</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
                <span class="k">case</span> <span class="n">Intersection</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">tau</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">split_rec</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">srcs</span><span class="p">,</span> <span class="n">split_rec</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">srcs</span><span class="p">,</span> <span class="n">delta</span><span class="p">))</span>
                <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">delta</span>

        <span class="k">return</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">ty</span><span class="o">.</span><span class="n">is_omega</span> <span class="k">else</span> <span class="p">[[([],</span> <span class="n">ty</span><span class="p">)],</span> <span class="o">*</span><span class="n">split_rec</span><span class="p">(</span><span class="n">ty</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[])]</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ####################################################################################################################</span>
<span class="sd">    ####################################################################################################################</span>
<span class="sd">    ####################################################################################################################</span>
<span class="sd">    #                                                                                                                  #</span>
<span class="sd">    #                                           COVER MACHINE (AND HELPERS)                                            #</span>
<span class="sd">    #                                                                                                                  #</span>
<span class="sd">    ####################################################################################################################</span>
<span class="sd">    ####################################################################################################################</span>
<span class="sd">    ####################################################################################################################</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="FiniteCombinatoryLogic._dcap"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._dcap">[docs]</a>    <span class="k">def</span> <span class="nf">_dcap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">tau</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given two types, checks if one is a subtype of the other. If yes,</span>
<span class="sd">        returns the more specific type, e.g. the subtype. If no, returns the</span>
<span class="sd">        intersection of the two.</span>

<span class="sd">        :param sigma: The first type to check.</span>
<span class="sd">        :param tau: The second type to check.</span>
<span class="sd">        :return: The resulting type (for merging that part of the MultiArrow).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtypes</span><span class="o">.</span><span class="n">check_subtype</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">tau</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">sigma</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtypes</span><span class="o">.</span><span class="n">check_subtype</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">tau</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Intersection</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span></div>

<div class="viewcode-block" id="FiniteCombinatoryLogic._partition_cover"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._partition_cover">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_partition_cover</span><span class="p">(</span>
        <span class="n">covered</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">],</span> <span class="n">to_cover</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This helper function partitions the elements of to_cover into two</span>
<span class="sd">        lists: If they are in covered, they get added to in_covered, if they</span>
<span class="sd">        aren&#39;t, they get added to not_in_covered. The idea is that elements</span>
<span class="sd">        that have already been covered are handled different then those that</span>
<span class="sd">        still need to be covered. This function computes exactly those sets.</span>
<span class="sd">        (p.45)</span>

<span class="sd">        :param covered: The set of types that are currently already</span>
<span class="sd">        covered. :param to_cover: The set of types that still needs to</span>
<span class="sd">        be covered. :return: The partitioned sets based on the</span>
<span class="sd">        membership in covered.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">in_covered</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">not_in_covered</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ty</span> <span class="ow">in</span> <span class="n">to_cover</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ty</span> <span class="ow">in</span> <span class="n">covered</span><span class="p">:</span>
                <span class="n">in_covered</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ty</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">not_in_covered</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ty</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">in_covered</span><span class="p">,</span> <span class="n">not_in_covered</span></div>

<div class="viewcode-block" id="FiniteCombinatoryLogic._still_possible"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._still_possible">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_still_possible</span><span class="p">(</span>
        <span class="n">splits</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]]],</span> <span class="n">to_cover</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This helper function checks each element of to_cover with regard to</span>
<span class="sd">        if it still could be covered by the content of splits. This is very</span>
<span class="sd">        intuitive, we check for the existence of a MultiArrow whose target is</span>
<span class="sd">        the type to be covered, with the left part not mattering. (p.46)</span>

<span class="sd">        :param splits: The list of MultiArrows (rules if you will) that</span>
<span class="sd">        can be used to cover the types in to_cover.</span>
<span class="sd">        :param to_cover: The list of Types to check coverability.</span>
<span class="sd">        :return: False, if there is any type in to_cover that can not be</span>
<span class="sd">        produced by any MultiArrow in splits at all. Else, True. (All types</span>
<span class="sd">        could at this step still be covered)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ty</span> <span class="ow">in</span> <span class="n">to_cover</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">ty</span> <span class="ow">in</span> <span class="n">covered</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">covered</span> <span class="ow">in</span> <span class="n">splits</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="FiniteCombinatoryLogic._merge_multi_arrow"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._merge_multi_arrow">[docs]</a>    <span class="k">def</span> <span class="nf">_merge_multi_arrow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arrow1</span><span class="p">:</span> <span class="n">MultiArrow</span><span class="p">,</span> <span class="n">arrow2</span><span class="p">:</span> <span class="n">MultiArrow</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MultiArrow</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merges two MultiArrows into a single MultiArrow with correct types.</span>
<span class="sd">        The MultiArrows have the same length. Each pair of types at the same</span>
<span class="sd">        spot is merged by _dcap, which selects the most specific type possible</span>
<span class="sd">        at that position (the subtype, or their intersection if there is no</span>
<span class="sd">        inheritance). (p.46)</span>

<span class="sd">        :param arrow1: The first MultiArrow.</span>
<span class="sd">        :param arrow2: The second MultiArrow.</span>
<span class="sd">        :return: The resulting MultiArrow from merging arrow1 and arrow2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dcap</span><span class="p">,</span> <span class="n">arrow1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arrow2</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dcap</span><span class="p">(</span>
            <span class="n">arrow1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">arrow2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="FiniteCombinatoryLogic._check_cover"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._check_cover">[docs]</a>    <span class="k">def</span> <span class="nf">_check_cover</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">splits</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]]],</span> <span class="n">to_cover</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CoverMachineInstruction</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Contains all the parts of the Step Relation where CheckCover is the</span>
<span class="sd">        current head. (p.46 f.)</span>

<span class="sd">        :param splits:</span>
<span class="sd">        :param to_cover:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">instr</span><span class="p">(</span>
            <span class="n">state</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">State</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">CoverMachineInstruction</span><span class="p">]]:</span>
            <span class="c1"># STEP_CheckOk (p.46) (because still possible to cover)</span>
            <span class="k">if</span> <span class="n">FiniteCombinatoryLogic</span><span class="o">.</span><span class="n">_still_possible</span><span class="p">(</span><span class="n">splits</span><span class="p">,</span> <span class="n">to_cover</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">state</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_cover</span><span class="p">(</span><span class="n">splits</span><span class="p">,</span> <span class="n">to_cover</span><span class="p">)]</span>
            <span class="c1"># STEP_CheckPrune (p.46) (because not still possible to cover)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">state</span><span class="p">,</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">instr</span></div>

<div class="viewcode-block" id="FiniteCombinatoryLogic._check_continue_cover"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._check_continue_cover">[docs]</a>    <span class="k">def</span> <span class="nf">_check_continue_cover</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">splits</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]]],</span>
        <span class="n">to_cover</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">],</span>
        <span class="n">current_result</span><span class="p">:</span> <span class="n">MultiArrow</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CoverMachineInstruction</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Contains all the parts of the StepRelation where CheckContinueCover</span>
<span class="sd">        is the current head. (p.46 f.)</span>

<span class="sd">        :param splits:</span>
<span class="sd">        :param to_cover:</span>
<span class="sd">        :param current_result:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">instr</span><span class="p">(</span>
            <span class="n">state</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">State</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">CoverMachineInstruction</span><span class="p">]]:</span>
            <span class="c1"># STEP_CheckContinueOk (p.46) (because still possible to continue)</span>
            <span class="k">if</span> <span class="n">FiniteCombinatoryLogic</span><span class="o">.</span><span class="n">_still_possible</span><span class="p">(</span><span class="n">splits</span><span class="p">,</span> <span class="n">to_cover</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">state</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_continue_cover</span><span class="p">(</span><span class="n">splits</span><span class="p">,</span> <span class="n">to_cover</span><span class="p">,</span> <span class="n">current_result</span><span class="p">)]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># STEP_CheckContinuePrune (p.46) (because no longer possible)</span>
                <span class="k">return</span> <span class="n">state</span><span class="p">,</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">instr</span></div>

<div class="viewcode-block" id="FiniteCombinatoryLogic._continue_cover"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._continue_cover">[docs]</a>    <span class="k">def</span> <span class="nf">_continue_cover</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">splits</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]]],</span>
        <span class="n">to_cover</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">],</span>
        <span class="n">current_result</span><span class="p">:</span> <span class="n">MultiArrow</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CoverMachineInstruction</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Contains all the parts of the Step Relation where ContinueCover is</span>
<span class="sd">        the current head. (p.46 f.)</span>

<span class="sd">        :param splits:</span>
<span class="sd">        :param to_cover:</span>
<span class="sd">        :param current_result:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">instr</span><span class="p">(</span>
            <span class="n">state</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">State</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">CoverMachineInstruction</span><span class="p">]]:</span>
            <span class="c1"># STEP_DoneContinue (p.47)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">splits</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">state</span><span class="p">,</span> <span class="p">[]</span>
            <span class="c1"># The covered type is the one that the right of the MultiArrow specifies (rather intuitive)</span>
            <span class="n">m</span><span class="p">,</span> <span class="n">covered</span> <span class="o">=</span> <span class="n">splits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_splits</span> <span class="o">=</span> <span class="n">splits</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="c1"># Calculate the Guard</span>
            <span class="n">freshly_covered</span><span class="p">,</span> <span class="n">uncovered</span> <span class="o">=</span> <span class="n">FiniteCombinatoryLogic</span><span class="o">.</span><span class="n">_partition_cover</span><span class="p">(</span>
                <span class="n">covered</span><span class="p">,</span> <span class="n">to_cover</span>
            <span class="p">)</span>
            <span class="c1"># STEP_SkipContinue (p.47)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">freshly_covered</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">state</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_continue_cover</span><span class="p">(</span><span class="n">_splits</span><span class="p">,</span> <span class="n">to_cover</span><span class="p">,</span> <span class="n">current_result</span><span class="p">)]</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_multi_arrow</span><span class="p">(</span><span class="n">current_result</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
            <span class="c1"># STEP_MergeDone (p.47) (uncovered is empty)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">uncovered</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">merged</span><span class="p">,</span> <span class="o">*</span><span class="n">state</span><span class="p">],</span> <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_continue_cover</span><span class="p">(</span><span class="n">_splits</span><span class="p">,</span> <span class="n">to_cover</span><span class="p">,</span> <span class="n">current_result</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="c1"># STEP_ContinueMergeAlways (p.47) (merge_multi_arrow and current_result match)</span>
            <span class="k">elif</span> <span class="n">merged</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">current_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">state</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_continue_cover</span><span class="p">(</span><span class="n">_splits</span><span class="p">,</span> <span class="n">uncovered</span><span class="p">,</span> <span class="n">merged</span><span class="p">)]</span>
            <span class="c1"># STEP_ContinueMergeOptions (p.47) (They don&#39;t match, and neither freshly_covered nor uncovered is empty)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">state</span><span class="p">,</span> <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_continue_cover</span><span class="p">(</span><span class="n">_splits</span><span class="p">,</span> <span class="n">uncovered</span><span class="p">,</span> <span class="n">merged</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_check_continue_cover</span><span class="p">(</span><span class="n">_splits</span><span class="p">,</span> <span class="n">to_cover</span><span class="p">,</span> <span class="n">current_result</span><span class="p">),</span>
                <span class="p">]</span>

        <span class="k">return</span> <span class="n">instr</span></div>

<div class="viewcode-block" id="FiniteCombinatoryLogic._cover"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._cover">[docs]</a>    <span class="k">def</span> <span class="nf">_cover</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">splits</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]]],</span> <span class="n">to_cover</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CoverMachineInstruction</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Contains all the parts of the Step Relation where Cover is the</span>
<span class="sd">        current head. (p.46 f.)</span>

<span class="sd">        :param splits:</span>
<span class="sd">        :param to_cover:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">instr</span><span class="p">(</span>
            <span class="n">state</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">State</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">CoverMachineInstruction</span><span class="p">]]:</span>
            <span class="c1"># STEP_Done (p.46) (splits is empty)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">splits</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">state</span><span class="p">,</span> <span class="p">[]</span>
            <span class="c1"># Compute guard again</span>
            <span class="n">m</span><span class="p">,</span> <span class="n">covered</span> <span class="o">=</span> <span class="n">splits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Parses tuple into separate vars</span>
            <span class="n">_splits</span> <span class="o">=</span> <span class="n">splits</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">freshly_covered</span><span class="p">,</span> <span class="n">uncovered</span> <span class="o">=</span> <span class="n">FiniteCombinatoryLogic</span><span class="o">.</span><span class="n">_partition_cover</span><span class="p">(</span>
                <span class="n">covered</span><span class="p">,</span> <span class="n">to_cover</span>
            <span class="p">)</span>
            <span class="c1"># STEP_Skip (p.46) (because freshly_covered is an empty list)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">freshly_covered</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">state</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_cover</span><span class="p">(</span><span class="n">_splits</span><span class="p">,</span> <span class="n">to_cover</span><span class="p">)]</span>
            <span class="c1"># STEP_AddDone (p.46) (because freshly_covered is not empty and uncovered is empty)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">uncovered</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">state</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_cover</span><span class="p">(</span><span class="n">_splits</span><span class="p">,</span> <span class="n">to_cover</span><span class="p">)]</span>
            <span class="c1"># STEP_Continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">state</span><span class="p">,</span> <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_continue_cover</span><span class="p">(</span><span class="n">_splits</span><span class="p">,</span> <span class="n">uncovered</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_check_cover</span><span class="p">(</span><span class="n">_splits</span><span class="p">,</span> <span class="n">to_cover</span><span class="p">),</span>
                <span class="p">]</span>

        <span class="k">return</span> <span class="n">instr</span></div>

<div class="viewcode-block" id="FiniteCombinatoryLogic._cover_machine"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._cover_machine">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_cover_machine</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">State</span><span class="p">,</span> <span class="n">program</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">CoverMachineInstruction</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">State</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Receives an initial state (cover) and a list of program</span>
<span class="sd">        instructions. These get processed in turn, by popping the head</span>
<span class="sd">        instruction. Each instruction itself is a callable, and the</span>
<span class="sd">        instructions implement the step relation. This function serves as a</span>
<span class="sd">        loop that keeps executing the instructions and manages the program</span>
<span class="sd">        stack and output state. (p.46 f.)</span>

<span class="sd">        :param state: A list of MultiArrows</span>
<span class="sd">        :param program: The stack of program instructions. Every Instruction</span>
<span class="sd">        is a callable and contains the actual step relation for the cover</span>
<span class="sd">        machine (p.46f.). The step relation is given across the functions _cover,</span>
<span class="sd">        _continue_cover, _check_continue_cover and _check_cover.</span>
<span class="sd">        :return: The output stack, which is a List of MultiArrows, which</span>
<span class="sd">        represents the computed cover.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">instructions</span><span class="p">:</span> <span class="n">deque</span><span class="p">[</span><span class="n">Iterator</span><span class="p">[</span><span class="n">CoverMachineInstruction</span><span class="p">]]</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="nb">iter</span><span class="p">(</span><span class="n">program</span><span class="p">)])</span>
        <span class="k">while</span> <span class="n">instructions</span><span class="p">:</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">instructions</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">instruction</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
                <span class="n">instructions</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
                <span class="n">state</span><span class="p">,</span> <span class="n">next_instructions</span> <span class="o">=</span> <span class="n">instruction</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                <span class="n">instructions</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">next_instructions</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">state</span></div>

<div class="viewcode-block" id="FiniteCombinatoryLogic._reduce_multi_arrows"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._reduce_multi_arrows">[docs]</a>    <span class="k">def</span> <span class="nf">_reduce_multi_arrows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function eliminates all MultiArrows from the given set (cover)</span>
<span class="sd">        that are redundant when considering subtyping.</span>

<span class="sd">        :param ms: The List of MultiArrows that we want to reduce to a minimal necessary size.</span>
<span class="sd">        :return: The reduced List.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">lesser_arg_vect</span><span class="p">:</span> <span class="n">MultiArrow</span><span class="p">,</span> <span class="n">greater_arg_vect</span><span class="p">:</span> <span class="n">MultiArrow</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Checks if lesser as a MultiArrow is a subtype of greater as a</span>
<span class="sd">            MultiArrow. A MultiArrow is a subtype of another if it has the same</span>
<span class="sd">            length, and each index within the left part of the lesser</span>
<span class="sd">            MultiArrow (representing one Type) is a subtype of the greater</span>
<span class="sd">            MultiArrow. (p.64, code lines 5-6)</span>

<span class="sd">            :param lesser_arg_vect: The MultiArrow to check for being a subtype of greater_arg_vect.</span>
<span class="sd">            :param greater_arg_vect: The MultiArrow to check against.</span>
<span class="sd">            :return: True if lesser_arg_vect is a subtype of greater_arg_vect, else False.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="p">(</span><span class="n">lesser_args</span><span class="p">,</span> <span class="n">greater_args</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">lesser_arg_vect</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">greater_arg_vect</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">lesser_args</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">greater_args</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">subtypes</span><span class="o">.</span><span class="n">check_subtype</span><span class="p">(</span><span class="n">lesser_arg</span><span class="p">,</span> <span class="n">greater_arg</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">lesser_arg</span><span class="p">,</span> <span class="n">greater_arg</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lesser_args</span><span class="p">,</span> <span class="n">greater_args</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">average_arguments_type_size</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">MultiArrow</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Metric to sort on.</span>

<span class="sd">            :param m:</span>
<span class="sd">            :return:</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">ty</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">size</span> <span class="o">+=</span> <span class="n">ty</span><span class="o">.</span><span class="n">size</span>
            <span class="k">return</span> <span class="n">size</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span>

        <span class="n">result</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">multi_arrow</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">average_arguments_type_size</span><span class="p">):</span>
            <span class="c1"># Check the current MultiArrow to potentially add against all MultiArrows currently in result.</span>
            <span class="c1"># If it is not a Subtype of any other MultiArrow in the result, add it to the Results.</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="n">check</span><span class="p">(</span><span class="n">multi_arrow</span><span class="p">,</span> <span class="n">in_result</span><span class="p">)</span> <span class="k">for</span> <span class="n">in_result</span> <span class="ow">in</span> <span class="n">result</span><span class="p">):</span>
                <span class="c1"># Whenever adding a new MultiArrow to the result, check if any of the current MultiArrows in the result</span>
                <span class="c1"># are a subtype of the newly added arrow. Remove those from the result.</span>
                <span class="c1"># (Necessary, we know we are not a subtype of any previous arrows present, but we do not know if adding</span>
                <span class="c1"># the new arrow makes previously added ones unnecessary, by being a subtype of the new arrow.)</span>
                <span class="c1"># (Implemented in reverse by filtering)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">multi_arrow</span><span class="p">,</span>
                    <span class="o">*</span><span class="p">(</span>
                        <span class="n">in_result</span>
                        <span class="k">for</span> <span class="n">in_result</span> <span class="ow">in</span> <span class="n">result</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">check</span><span class="p">(</span><span class="n">in_result</span><span class="p">,</span> <span class="n">multi_arrow</span><span class="p">)</span>
                    <span class="p">),</span>
                <span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ####################################################################################################################</span>
<span class="sd">    ####################################################################################################################</span>
<span class="sd">    ####################################################################################################################</span>
<span class="sd">    #                                                                                                                  #</span>
<span class="sd">    #                                     INHABITATION MACHINE (AND HELPERS)                                           #</span>
<span class="sd">    #                                                                                                                  #</span>
<span class="sd">    ####################################################################################################################</span>
<span class="sd">    ####################################################################################################################</span>
<span class="sd">    ####################################################################################################################</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="FiniteCombinatoryLogic._compute_fail_existing"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._compute_fail_existing">[docs]</a>    <span class="k">def</span> <span class="nf">_compute_fail_existing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">rules</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Rule</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="n">Type</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes if the target or a supertype of it have already failed/been</span>
<span class="sd">        uninhabited [1]. Also computes if the target has already been a target</span>
<span class="sd">        in the set of rules or has already failed [2]. A supertype being</span>
<span class="sd">        uninhabited also proves that all of its subtypes are uninhabitable.</span>

<span class="sd">        If a Failed(target) is found, that means it was failed and existing.</span>
<span class="sd">        If a Failed(supertype of target) is found, that means it failed, but we must check for existence.</span>
<span class="sd">        If neither was the case, we know it was not failed so far, but must still check for existence.</span>
<span class="sd">        The last case is the remaining combination.</span>

<span class="sd">        :param rules: This is the set of stable rules, referred to as G_stable in the algorithm.</span>
<span class="sd">        :param target: This is the type to compute for.</span>
<span class="sd">        :return: Tuple of Booleans, consisting of ([1], [2]) / (failed, existing).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rest_of_rules</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Rule</span><span class="p">]</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">rules</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">to_check</span> <span class="o">:=</span> <span class="nb">next</span><span class="p">(</span><span class="n">rest_of_rules</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">match</span> <span class="n">to_check</span><span class="p">:</span>
                <span class="k">case</span> <span class="n">Failed</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span>
                <span class="k">case</span> <span class="n">Failed</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtypes</span><span class="o">.</span><span class="n">check_subtype</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">Failed</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="ow">in</span> <span class="n">rest_of_rules</span>
                <span class="k">case</span><span class="w"> </span><span class="n">Apply</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="k">if</span> <span class="n">arg</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span>
                <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                    <span class="k">continue</span>
        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="FiniteCombinatoryLogic._commit_multi_arrow"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._commit_multi_arrow">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_commit_multi_arrow</span><span class="p">(</span><span class="n">combinator</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">MultiArrow</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">deque</span><span class="p">[</span><span class="n">Rule</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts a MultiArrow into a set of rules that the inhabitation</span>
<span class="sd">        machine can process. This is done by expanding the MultiArrow to nested</span>
<span class="sd">        Arrows and creating the corresponding &quot;Apply&quot; rules. Finally, after all</span>
<span class="sd">        Apply rules the combinator entails have been computed, the combinator</span>
<span class="sd">        itself is added as a rule as well.</span>

<span class="sd">        Note: This ordering created here is the reason why popLeft is equivalent to dropTargets.</span>

<span class="sd">        :param combinator: The combinator being evaluated.</span>
<span class="sd">        :param m: The type of the combinator being evaluated.</span>
<span class="sd">        :return: The resulting rules for the inhabitation machine to process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span><span class="p">:</span> <span class="n">deque</span><span class="p">[</span><span class="n">Rule</span><span class="p">]</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="n">srcs</span><span class="p">,</span> <span class="n">tgt</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">srcs</span><span class="p">:</span>
            <span class="c1"># If I have A -&gt; B -&gt; C, this makes Arrow(B,C), followed by Arrow(A,Arrow(B,C)) and so on.</span>
            <span class="c1"># This notion is all that&#39;s happening in this loop.</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">Arrow</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">tgt</span><span class="p">)</span>
            <span class="c1"># The target type of Apply is tgt, the function of Apply are the expanded MultiArrows, and the source type</span>
            <span class="c1"># is the left side index that is currently being expanded</span>
            <span class="n">result</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">Apply</span><span class="p">(</span><span class="n">tgt</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">src</span><span class="p">))</span>
            <span class="c1"># Quintessentially moves target on set of brackets further outwards.</span>
            <span class="n">tgt</span> <span class="o">=</span> <span class="n">arr</span>
        <span class="n">result</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">Combinator</span><span class="p">(</span><span class="n">tgt</span><span class="p">,</span> <span class="n">combinator</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="FiniteCombinatoryLogic._commit_updates"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._commit_updates">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_commit_updates</span><span class="p">(</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">combinator</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">covers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">deque</span><span class="p">[</span><span class="n">deque</span><span class="p">[</span><span class="n">Rule</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Takes the output produced by the cover machine and converts it into</span>
<span class="sd">        a list of lists, with each sublist representing an ordered set of Apply</span>
<span class="sd">        rules and a Combinator rule, which can be added to the G_targets set.</span>
<span class="sd">        The ordering is the ordering given on the bottom of page 69.</span>

<span class="sd">        The MultiArrows that get expanded to Rules are not just the contents of the cover,</span>
<span class="sd">        but use the given target instead of their own target. (Lemma 27, p. 63)</span>

<span class="sd">        :param target: The target type to create new rules for.</span>
<span class="sd">        :param combinator: The combinator object that will become a rule and is associated with the created rules.</span>
<span class="sd">        :param covers: The list of MultiArrows computed by the cover machine.</span>
<span class="sd">        :return: The resulting list of lists, representing the segmented rules.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span><span class="p">:</span> <span class="n">deque</span><span class="p">[</span><span class="n">deque</span><span class="p">[</span><span class="n">Rule</span><span class="p">]]</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cover</span> <span class="ow">in</span> <span class="n">covers</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="c1"># Convert the MultiArrow to Rules (expand it)</span>
                <span class="n">FiniteCombinatoryLogic</span><span class="o">.</span><span class="n">_commit_multi_arrow</span><span class="p">(</span>
                    <span class="n">combinator</span><span class="p">,</span> <span class="p">(</span><span class="n">cover</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">target</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="FiniteCombinatoryLogic._accumulate_covers"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._accumulate_covers">[docs]</a>    <span class="k">def</span> <span class="nf">_accumulate_covers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span>
        <span class="n">to_cover</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">],</span>
        <span class="n">combinator</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span>
        <span class="n">combinator_type</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">deque</span><span class="p">[</span><span class="n">deque</span><span class="p">[</span><span class="n">Rule</span><span class="p">]],</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes all the covers necessary for a given combinators type, a</span>
<span class="sd">        set of types that need to be covered and a target Type that needs to be</span>
<span class="sd">        inhabitated and converts the covers into a segmented list of lists of</span>
<span class="sd">        rules that the inhabitation machine can process. Note: The partial from</span>
<span class="sd">        _inhabit_cover fixes the first two arguments. This can intuitively be</span>
<span class="sd">        understood as us checking all combinators in the repository against the</span>
<span class="sd">        target and using the cover machine to find out if the combinator can</span>
<span class="sd">        allow us to cover the target.</span>

<span class="sd">        :param target: The Type to compute covers for.</span>
<span class="sd">        :param to_cover: A list of types for the target to be covered. Recursively computed by organized.</span>
<span class="sd">        :param combinator: The combinator that we are preparing for the cover machine.</span>
<span class="sd">        :param combinator_type: The type of the combinator.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">cover_instr</span><span class="p">(</span><span class="n">ms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">CoverMachineInstruction</span><span class="p">:</span>
            <span class="n">splits</span><span class="p">:</span> <span class="nb">list</span><span class="p">[(</span><span class="n">MultiArrow</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">])]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">map</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="p">(</span>
                        <span class="c1"># The first part of splits is of course just the MultiArrow</span>
                        <span class="n">m</span><span class="p">,</span>
                        <span class="c1"># The type covered by the MultiArrow initially is itself and all its supertypes</span>
                        <span class="c1"># of course only w.r.t. the types we are seeking to cover, to_cover</span>
                        <span class="nb">set</span><span class="p">(</span>
                            <span class="nb">filter</span><span class="p">(</span>
                                <span class="k">lambda</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtypes</span><span class="o">.</span><span class="n">check_subtype</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">),</span> <span class="n">to_cover</span>
                            <span class="p">)</span>
                        <span class="p">),</span>
                    <span class="p">),</span>
                    <span class="n">ms</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cover</span><span class="p">(</span><span class="n">splits</span><span class="p">,</span> <span class="n">to_cover</span><span class="p">)</span>

        <span class="c1"># For each part of the combinator_type create a corresponding cover machine instruction as given above</span>
        <span class="c1"># Call the cover_machine with that set of computed instructions</span>
        <span class="n">covers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">MultiArrow</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cover_machine</span><span class="p">(</span>
            <span class="p">[],</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">cover_instr</span><span class="p">,</span> <span class="n">combinator_type</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="c1"># Eliminate redundant MultiArrows from the computed cover and feed the cover to the inhabitation machine as</span>
        <span class="c1"># its next targets</span>
        <span class="n">next_rules</span><span class="p">:</span> <span class="n">deque</span><span class="p">[</span><span class="n">deque</span><span class="p">[</span><span class="n">Rule</span><span class="p">]]</span> <span class="o">=</span> <span class="n">FiniteCombinatoryLogic</span><span class="o">.</span><span class="n">_commit_updates</span><span class="p">(</span>
            <span class="n">target</span><span class="p">,</span> <span class="n">combinator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_multi_arrows</span><span class="p">(</span><span class="n">covers</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">next_rules</span><span class="p">,</span> <span class="ow">not</span> <span class="n">covers</span></div>

<div class="viewcode-block" id="FiniteCombinatoryLogic._inhabit_cover"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._inhabit_cover">[docs]</a>    <span class="k">def</span> <span class="nf">_inhabit_cover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">todo_rules</span><span class="p">:</span> <span class="n">deque</span><span class="p">[</span><span class="n">deque</span><span class="p">[</span><span class="n">Rule</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># Remove all types that reduce to Omega under subtyping (p.28 f)</span>
        <span class="c1"># For what organized returns, check Arrows etc. implementation of it</span>
        <span class="c1"># E.g. Arrow propagates, Arrow(A, B).organized is Arrow(A, B.organized) etc.</span>
        <span class="n">prime_factors</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtypes</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">organized</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processes</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span>
                <span class="c1"># The partial calls accumulate_covers with  target and prime factors always the same</span>
                <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_accumulate_covers</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">prime_factors</span><span class="p">),</span>
                <span class="c1"># This is the iterable that contains tuples that each provide combinator and combinator_type</span>
                <span class="c1"># In practice, this is the dict that is used as a repo, but in splitted</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">splitted_repository</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span>
                <span class="c1"># This is just the chunksize (I think the missing keyword causes an error here)</span>
                <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splitted_repository</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">processes</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="n">failed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># All accumulated covers from checking against every combinator</span>
        <span class="k">for</span> <span class="n">rules</span><span class="p">,</span> <span class="n">local_fail</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
            <span class="c1"># We add the rules coming from those combinators that were able to cover the target</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">local_fail</span><span class="p">:</span>
                <span class="n">failed</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">todo_rules</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rules</span><span class="p">)</span>
        <span class="c1"># If none could cover the target, we fail.</span>
        <span class="k">return</span> <span class="n">failed</span></div>

<div class="viewcode-block" id="FiniteCombinatoryLogic._omega_rules"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._omega_rules">[docs]</a>    <span class="k">def</span> <span class="nf">_omega_rules</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="n">Rule</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">Apply</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">target</span><span class="p">),</span>
            <span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">Combinator</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">splitted_repository</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
        <span class="p">}</span></div>

<div class="viewcode-block" id="FiniteCombinatoryLogic._inhabitation_step"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._inhabitation_step">[docs]</a>    <span class="k">def</span> <span class="nf">_inhabitation_step</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">stable</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Rule</span><span class="p">],</span> <span class="n">targets</span><span class="p">:</span> <span class="n">deque</span><span class="p">[</span><span class="n">deque</span><span class="p">[</span><span class="n">Rule</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Implements the inhabitation machine&#39;s state transition function</span>
<span class="sd">        (p.68).</span>

<span class="sd">        :param stable:</span>
<span class="sd">        :param targets:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">targets</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">targets</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">targets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="k">match</span> <span class="n">target</span><span class="p">:</span>
                    <span class="c1"># Implements rule group 1 (p.68)</span>
                    <span class="c1"># Simply explained, using a Combinator is trivially always a valid rule</span>
                    <span class="k">case</span><span class="w"> </span><span class="n">Combinator</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
                        <span class="n">stable</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                    <span class="k">case</span><span class="w"> </span><span class="n">Apply</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">stable</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">case</span><span class="w"> </span><span class="n">Apply</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">target_type</span><span class="p">):</span>
                        <span class="c1"># Compute the value of fail_existing that the state transition bases its actions on (p.68)</span>
                        <span class="n">failed</span><span class="p">,</span> <span class="n">existing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_fail_existing</span><span class="p">(</span>
                            <span class="n">stable</span><span class="p">,</span> <span class="n">target_type</span>
                        <span class="p">)</span>
                        <span class="c1"># Implement lines 8-11 of Pseudocode on page 68.</span>
                        <span class="k">if</span> <span class="n">failed</span><span class="p">:</span>
                            <span class="c1"># If target_type is a failure but not yet marked in stable, mark it.</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">existing</span><span class="p">:</span>
                                <span class="n">stable</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Failed</span><span class="p">(</span><span class="n">target_type</span><span class="p">))</span>
                        <span class="c1"># Implement lines 12-13 from page 68.</span>
                        <span class="c1"># If an Application already existed with the same target, then this one is also fine.</span>
                        <span class="k">elif</span> <span class="n">existing</span><span class="p">:</span>
                            <span class="n">stable</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                        <span class="c1"># Implement lines 14-15, page 68.</span>
                        <span class="c1"># If the target of the application doesn&#39;t matter, we can definitely add it to the stable rules.</span>
                        <span class="k">elif</span> <span class="n">target_type</span><span class="o">.</span><span class="n">is_omega</span><span class="p">:</span>
                            <span class="c1"># omega_rules generates the derived subtype rules for omega and is a pure helper function,</span>
                            <span class="c1"># as explained in the middle of page 70.</span>
                            <span class="n">stable</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_omega_rules</span><span class="p">(</span><span class="n">target_type</span><span class="p">)</span>
                            <span class="n">stable</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># Implements group 5 from pseudocode on page 68.</span>
                            <span class="c1"># Note that inhabit_cover can modify targets as it computed additional inhabitation targets.</span>
                            <span class="n">inhabit_failed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inhabit_cover</span><span class="p">(</span><span class="n">target_type</span><span class="p">,</span> <span class="n">targets</span><span class="p">)</span>
                            <span class="c1"># Case 1, inhabitation for some part of the sequence belonging to a MultiArrow plus</span>
                            <span class="c1"># Combinator failed.</span>
                            <span class="k">if</span> <span class="n">inhabit_failed</span><span class="p">:</span>
                                <span class="c1"># Mark the failure in stable, so that compute_failed_existing can improve efficiency</span>
                                <span class="n">stable</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Failed</span><span class="p">(</span><span class="n">target_type</span><span class="p">))</span>
                                <span class="c1"># Drop targets up to next combinator</span>
                                <span class="n">targets</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># Else add rule to the result rules (stable)</span>
                                <span class="n">stable</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                    <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid type of rule: </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This is dropTargets (p.67) and represents a target being done processing</span>
                <span class="c1"># Note that this seems to differ from the formal definition given.</span>
                <span class="c1"># This is due to the different data structure compared to page 68.</span>
                <span class="c1"># Each target here is a subsequence of G_targets, that has been split by occurrence of Combinators.</span>
                <span class="c1"># Thus popping a whole subsequence indeed represents dropping everything until the next combinator.</span>
                <span class="c1"># This is possible because of targets internal order, as described on the bottom of page 69.</span>
                <span class="n">targets</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span></div>

<div class="viewcode-block" id="FiniteCombinatoryLogic._inhabitation_machine"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._inhabitation_machine">[docs]</a>    <span class="k">def</span> <span class="nf">_inhabitation_machine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stable</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Rule</span><span class="p">],</span> <span class="n">targets</span><span class="p">:</span> <span class="n">deque</span><span class="p">[</span><span class="n">deque</span><span class="p">[</span><span class="n">Rule</span><span class="p">]]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Implements the actual inhabitation machine. This calls</span>
<span class="sd">        _inhabitation_step until the list of candidate rules to include in the</span>
<span class="sd">        tree grammar is empty (targets). Variable stable contains the rules</span>
<span class="sd">        that are part of the final computed tree grammar. The contents of</span>
<span class="sd">        stable are, in fact, stable, as in the list is only appended too, and</span>
<span class="sd">        previously committed members of the list do not get modified or</span>
<span class="sd">        removed. (p.69 f.)</span>

<span class="sd">        :param stable:</span>
<span class="sd">        :param targets:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inhabitation_step</span><span class="p">(</span><span class="n">stable</span><span class="p">,</span> <span class="n">targets</span><span class="p">):</span>
            <span class="k">pass</span></div>

<div class="viewcode-block" id="FiniteCombinatoryLogic.inhabit"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic.inhabit">[docs]</a>    <span class="k">def</span> <span class="nf">inhabit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">targets</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InhabitationResult</span><span class="p">:</span>
        <span class="n">result</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Rule</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">all_targets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span>
        <span class="n">todo_rules</span><span class="p">:</span> <span class="n">deque</span><span class="p">[</span><span class="n">deque</span><span class="p">[</span><span class="n">Rule</span><span class="p">]]</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">all_targets</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">is_omega</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_omega_rules</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">failed</span><span class="p">,</span> <span class="n">existing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_fail_existing</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">failed</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">existing</span><span class="p">:</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Failed</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inhabit_failed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inhabit_cover</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">todo_rules</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">inhabit_failed</span><span class="p">:</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Failed</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_inhabitation_machine</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">todo_rules</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">InhabitationResult</span><span class="p">(</span>
            <span class="n">targets</span><span class="o">=</span><span class="n">all_targets</span><span class="p">,</span> <span class="n">rules</span><span class="o">=</span><span class="n">FiniteCombinatoryLogic</span><span class="o">.</span><span class="n">_prune</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="FiniteCombinatoryLogic._ground_types_of"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._ground_types_of">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_ground_types_of</span><span class="p">(</span><span class="n">rules</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Rule</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]:</span>
        <span class="n">ground</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">next_ground</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">rule</span><span class="o">.</span><span class="n">target</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">rules</span> <span class="k">if</span> <span class="n">rule</span><span class="o">.</span><span class="n">is_combinator</span><span class="p">}</span>

        <span class="k">while</span> <span class="n">next_ground</span><span class="p">:</span>
            <span class="n">ground</span> <span class="o">|=</span> <span class="n">next_ground</span>
            <span class="n">next_ground</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">:</span>
                <span class="k">match</span> <span class="n">rule</span><span class="p">:</span>
                    <span class="k">case</span> <span class="n">Apply</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">function_type</span><span class="p">,</span> <span class="n">argument_type</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span>
                        <span class="n">function_type</span> <span class="ow">in</span> <span class="n">ground</span>
                        <span class="ow">and</span> <span class="n">argument_type</span> <span class="ow">in</span> <span class="n">ground</span>
                        <span class="ow">and</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ground</span>
                    <span class="p">):</span>
                        <span class="n">next_ground</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                    <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                        <span class="k">pass</span>
        <span class="k">return</span> <span class="n">ground</span></div>

<div class="viewcode-block" id="FiniteCombinatoryLogic._prune"><a class="viewcode-back" href="../../modules/fcl.module.html#cls.fcl.FiniteCombinatoryLogic._prune">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_prune</span><span class="p">(</span><span class="n">rules</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Rule</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="n">Rule</span><span class="p">]:</span>
        <span class="n">ground_types</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Type</span><span class="p">]</span> <span class="o">=</span> <span class="n">FiniteCombinatoryLogic</span><span class="o">.</span><span class="n">_ground_types_of</span><span class="p">(</span><span class="n">rules</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">:</span>
            <span class="k">match</span> <span class="n">rule</span><span class="p">:</span>
                <span class="k">case</span><span class="w"> </span><span class="n">Apply</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ground_types</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Failed</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
                <span class="k">case</span><span class="w"> </span><span class="n">Apply</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="n">function_type</span><span class="p">,</span> <span class="n">argument_type</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                    <span class="n">function_type</span> <span class="ow">in</span> <span class="n">ground_types</span> <span class="ow">and</span> <span class="n">argument_type</span> <span class="ow">in</span> <span class="n">ground_types</span>
                <span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Jan Bessai.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>